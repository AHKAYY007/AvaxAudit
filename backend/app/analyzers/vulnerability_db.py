import json
import threading
from typing import Dict, Any, Optional

from pathlib import Path

class VulnerabilityDB:
    """Thread-safe, in-memory store of vulnerability metadata."""

    _instance = None
    _lock = threading.Lock()

    def __new__(cls, db_path: Optional[str] = None):
        # Singleton: load once
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._init(db_path)
            return cls._instance

    def _init(self, db_path: Optional[str]):
        self.db_path = db_path or Path(__file__).parent / "vuln_db.json"
        self._load_db()

    def _load_db(self):
        try:
            with open(self.db_path, 'r', encoding='utf-8') as f:
                self._data: Dict[str, Any] = json.load(f)
        except FileNotFoundError:
            self._data = {}
        except json.JSONDecodeError as e:
            raise RuntimeError(f"Failed to parse vulnerability DB: {e}")

    def reload(self):
        """Reload from disk (in case you update JSON)."""
        with self._lock:
            self._load_db()

    def get(self, rule_id: str) -> Optional[Dict[str, Any]]:
        """Fetch metadata for a given rule or SWC ID."""
        return self._data.get(rule_id)

    def all(self) -> Dict[str, Any]:
        """Return the entire vulnerability map."""
        return self._data

    def add(self, rule_id: str, metadata: Dict[str, Any]):
        """Add or update a vulnerability entry at runtime."""
        with self._lock:
            self._data[rule_id] = metadata

    def save(self):
        """Persist current in-memory DB back to JSON."""
        with open(self.db_path, 'w', encoding='utf-8') as f:
            json.dump(self._data, f, indent=2, ensure_ascii=False)
